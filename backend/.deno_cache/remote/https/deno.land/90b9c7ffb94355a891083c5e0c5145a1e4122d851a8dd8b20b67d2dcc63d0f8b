import type { CorsOptions, CorsOptionsDelegate } from "./types.ts";
import { Cors } from "./cors.ts";

interface Req {
  serverRequest: {
    method: string;
    headers: {
      get(headerKey: string): string | null | undefined;
    };
  };
}

interface Res {
  status?: number | string;
  headers: {
    get(headerKey: string): string | null | undefined;
    set(headerKey: string, headerValue: string): any;
  };
}

/**
 * mithCors middleware wrapper
 * @param o CorsOptions | CorsOptionsDelegate
 * @link https://github.com/tajpouria/cors/blob/master/README.md#cors
 */
export const mithCors = <
  RequestT extends Req = any,
  ResponseT extends Res = any,
  MiddlewareT extends (
    request: RequestT,
    response: ResponseT,
    next: (...args: any) => any,
  ) => any = any,
>(
  o?: CorsOptions | CorsOptionsDelegate<RequestT>,
) => {
  const corsOptionsDelegate = Cors.produceCorsOptionsDelegate<
    CorsOptionsDelegate<RequestT>
  >(o);

  return (async (request, response, next) => {
    const serverRequest = request.serverRequest;
    try {
      const options = await corsOptionsDelegate(request);

      const corsOptions = Cors.produceCorsOptions(options || {});
      const originDelegate = Cors.produceOriginDelegate(corsOptions);

      if (originDelegate) {
        const requestMethod = serverRequest.method;
        const getRequestHeader = (headerKey: string) =>
          serverRequest.headers.get(headerKey);
        const getResponseHeader = (headerKey: string) =>
          response.headers.get(headerKey);
        const setResponseHeader = (headerKey: string, headerValue: string) =>
          response.headers.set(headerKey, headerValue);
        const setStatus = (
          statusCode: number,
        ) => (response.status = statusCode);
        const end = () => {};

        const origin = await originDelegate(getRequestHeader("origin"));

        if (!origin) return next();
        else {
          corsOptions.origin = origin;

          return new Cors({
            corsOptions,
            requestMethod,
            getRequestHeader,
            getResponseHeader,
            setResponseHeader,
            setStatus,
            next,
            end,
          }).configureHeaders();
        }
      }
    } catch (error) {
      console.error(error);
    }

    return next();
  }) as MiddlewareT;
};

// denoCacheMetadata={"headers":{"access-control-allow-origin":"*","etag":"\"dabfa90f706d1159fda5a8de46774d8b\"","cache-control":"public, max-age=31536000, immutable","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","server-timing":"fetchSource;dur=20","strict-transport-security":"max-age=63072000; includeSubDomains; preload","accept-ranges":"bytes","content-type":"application/typescript; charset=utf-8","age":"23289415","server":"deno/gcp-europe-west3","x-amz-version-id":"efiSlTadPSy_JyP8nHxzh1HUICTsJKwt","x-cache":"Hit from cloudfront","x-amz-cf-pop":"FRA56-P5","vary":"Accept-Encoding, Origin","cross-origin-embedder-policy":"same-origin","x-frame-options":"DENY","content-length":"2351","cross-origin-opener-policy":"same-origin","via":"http/2 edgeproxy-h","cross-origin-resource-policy":"same-origin","last-modified":"Wed, 26 May 2021 10:15:33 GMT","x-amz-replication-status":"COMPLETED","date":"Sat, 08 Feb 2025 01:31:55 GMT","referrer-policy":"strict-origin-when-cross-origin","x-content-type-options":"nosniff","x-amz-cf-id":"yzRw-jBTJ1d9MsfOPYzL47botTkJBUAW7iHWZcnI2f-1ReO7FCUZpg=="},"url":"https://deno.land/x/cors@v1.2.2/mithCors.ts","time":1762267729}