// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.

import type { Application, State } from "./application.ts";

export interface Listener {
  addr: { hostname: string; port: number };
}

export interface OakServer<T> extends AsyncIterable<T> {
  close(): void | Promise<void>;
  listen(): Listener | Promise<Listener>;
  [Symbol.asyncIterator](): AsyncIterableIterator<T>;
}

export interface ServerRequest {
  readonly headers: Headers;
  readonly method: string;
  readonly rawUrl?: string;
  readonly remoteAddr: string | undefined;
  readonly request?: Request;
  readonly url: string;
  // deno-lint-ignore no-explicit-any
  error(reason?: any): void;
  getBody(): ReadableStream<Uint8Array> | null;
  respond(response: Response): void | Promise<void>;
  upgrade?(options?: UpgradeWebSocketOptions): WebSocket;
}

/** The abstract constructor interface that custom servers need to adhere to
 * when using with an {@linkcode Application}. */
export interface ServerConstructor<T extends ServerRequest> {
  // deno-lint-ignore no-explicit-any
  new <AS extends State = Record<string, any>>(
    app: Application<AS>,
    options: Omit<ServeOptions | ServeTlsOptions, "signal">,
  ): OakServer<T>;
  prototype: OakServer<T>;
  type?: "native" | "node" | "bun";
}

export type Data = string | number[] | ArrayBuffer | Uint8Array;
export type Key = string | number[] | ArrayBuffer | Uint8Array;

export interface UpgradeWebSocketOptions {
  protocol?: string;
}

export type UpgradeWebSocketFn = (
  request: Request,
  options?: UpgradeWebSocketOptions,
) => WebSocketUpgrade;

interface WebSocketUpgrade {
  response: Response;
  socket: WebSocket;
}

export interface NetAddr {
  transport: "tcp" | "udp";
  hostname: string;
  port: number;
}

export interface ServeHandlerInfo {
  remoteAddr: Deno.NetAddr;
}

export type ServeHandler = (
  request: Request,
  info: ServeHandlerInfo,
) => Response | Promise<Response>;

export interface ServeOptions {
  port?: number;
  hostname?: string;
  signal?: AbortSignal;
  reusePort?: boolean;
  onError?: (error: unknown) => Response | Promise<Response>;
  onListen?: (params: { hostname: string; port: number }) => void;
}

export interface ServeTlsOptions extends ServeOptions {
  cert: string;
  key: string;
}

export interface ServeInit {
  handler: ServeHandler;
}

export interface HttpServer extends AsyncDisposable {
  finished: Promise<void>;
  ref(): void;
  unref(): void;
  shutdown(): Promise<void>;
}

// denoCacheMetadata={"headers":{"cross-origin-embedder-policy":"same-origin","x-amz-server-side-encryption":"AES256","x-amz-version-id":"TWwcwL1WIW6eHl1c.t5AiXyD3mYESqlE","access-control-allow-origin":"*","vary":"Accept-Encoding, Origin","via":"http/2 edgeproxy-h","x-frame-options":"DENY","server-timing":"fetchSource;dur=12","x-amz-replication-status":"PENDING","cross-origin-opener-policy":"same-origin","content-type":"application/typescript; charset=utf-8","age":"7573205","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","x-amz-cf-pop":"FRA56-P5","x-content-type-options":"nosniff","etag":"\"c66c31cfe71f16b195775aeb20929c42\"","referrer-policy":"strict-origin-when-cross-origin","content-length":"2490","last-modified":"Fri, 08 Aug 2025 23:08:39 GMT","x-cache":"Hit from cloudfront","cross-origin-resource-policy":"same-origin","date":"Fri, 08 Aug 2025 23:08:45 GMT","server":"deno/gcp-europe-west3","strict-transport-security":"max-age=63072000; includeSubDomains; preload","cache-control":"public, max-age=31536000, immutable","x-amz-cf-id":"XPDFkqEb1gWzUNSpnYyao2pspzlqSc1mng602FQRv7-ZYm_6GeZs3w==","accept-ranges":"bytes"},"url":"https://deno.land/x/oak@v17.1.6/types.ts","time":1762267729}