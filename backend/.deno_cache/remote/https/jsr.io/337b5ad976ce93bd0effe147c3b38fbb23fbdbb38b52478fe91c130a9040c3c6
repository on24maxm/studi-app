// Copyright 2018-2025 the Deno authors. MIT license.
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import { compareSpecs, isQuality, type Specificity } from "./common.ts";

interface EncodingSpecificity extends Specificity {
  encoding?: string;
}

const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

function parseEncoding(
  str: string,
  i: number,
): EncodingSpecificity | undefined {
  const match = simpleEncodingRegExp.exec(str);
  if (!match) {
    return undefined;
  }

  const encoding = match[1]!;
  let q = 1;
  if (match[2]) {
    const params = match[2].split(";");
    for (const param of params) {
      const p = param.trim().split("=");
      if (p[0] === "q" && p[1]) {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return { encoding, o: undefined, q, i, s: undefined };
}

function specify(
  encoding: string,
  spec: EncodingSpecificity,
  i = -1,
): Specificity | undefined {
  if (!spec.encoding) {
    return;
  }
  let s = 0;
  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
    s = 1;
  } else if (spec.encoding !== "*") {
    return;
  }

  return {
    i,
    o: spec.i,
    q: spec.q,
    s,
  };
}

function parseAcceptEncoding(accept: string): EncodingSpecificity[] {
  const accepts = accept.split(",");
  const parsedAccepts: EncodingSpecificity[] = [];
  let hasIdentity = false;
  let minQuality = 1;

  for (const [i, accept] of accepts.entries()) {
    const encoding = parseEncoding(accept.trim(), i);

    if (encoding) {
      parsedAccepts.push(encoding);
      hasIdentity = hasIdentity || !!specify("identity", encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    parsedAccepts.push({
      encoding: "identity",
      o: undefined,
      q: minQuality,
      i: accepts.length - 1,
      s: undefined,
    });
  }

  return parsedAccepts;
}

function getEncodingPriority(
  encoding: string,
  accepted: Specificity[],
  index: number,
): Specificity {
  let priority: Specificity = { o: -1, q: 0, s: 0, i: 0 };

  for (const s of accepted) {
    const spec = specify(encoding, s, index);

    if (
      spec &&
      (priority.s! - spec.s! || priority.q - spec.q ||
          priority.o! - spec.o!) <
        0
    ) {
      priority = spec;
    }
  }

  return priority;
}

/** Given an `Accept-Encoding` string, parse out the encoding returning a
 * negotiated encoding based on the `provided` encodings otherwise just a
 * prioritized array of encodings. */
export function preferredEncodings(
  accept: string,
  provided?: string[],
): string[] {
  const accepts = parseAcceptEncoding(accept);

  if (!provided) {
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map((spec) => spec.encoding!);
  }

  const priorities = provided.map((type, index) =>
    getEncodingPriority(type, accepts, index)
  );

  return priorities
    .filter(isQuality)
    .sort(compareSpecs)
    .map((priority) => provided[priorities.indexOf(priority)]!);
}

// denoCacheMetadata={"headers":{"access-control-allow-origin":"*","x-goog-storage-class":"STANDARD","access-control-expose-headers":"*","via":"1.1 google","x-goog-stored-content-length":"4337","date":"Tue, 04 Nov 2025 14:33:20 GMT","x-goog-stored-content-encoding":"identity","content-type":"text/typescript","x-jsr-cache-id":"FRA","x-content-type-options":"nosniff","x-goog-hash":"crc32c=cd1edg==,md5=6ABmIKLZ05D2CdhEdS9nsw==","etag":"\"e8006620a2d9d390f609d844752f67b3\"","x-goog-metageneration":"1","cache-control":"public, max-age=31536000, immutable","expires":"Wed, 04 Nov 2026 14:33:20 GMT","age":"929","last-modified":"Tue, 22 Jul 2025 13:15:20 GMT","accept-ranges":"bytes","content-length":"4337","x-guploader-uploadid":"AOCedOGLoMj5_nWOF9JmiTOSjYXAue9vNO_9LdYcZXIm9ZsjX_eMjymIEgUy5BF8hVhFkZSXkMMgHi4","x-goog-generation":"1753190120221197","server":"UploadServer","cross-origin-resource-policy":"cross-origin","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-jsr-cache-status":"hit","x-robots-tag":"noindex"},"url":"https://jsr.io/@std/http/1.0.20/_negotiation/encoding.ts","time":1762267730}