// Copyright 2018-2025 the Deno authors. MIT license.
// This module is browser compatible.
/**
 * Provides functions for dealing with and matching ETags, including
 * {@linkcode eTag} to calculate an etag for a given entity,
 * {@linkcode ifMatch} for validating if an ETag matches against a `If-Match`
 * header and {@linkcode ifNoneMatch} for validating an Etag against an
 * `If-None-Match` header.
 *
 * See further information on the `ETag` header on
 * {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag | MDN}.
 *
 * @module
 */ import { encodeBase64 as base64Encode } from "jsr:@std/encoding@^1.0.10/base64";
const encoder = new TextEncoder();
const DEFAULT_ALGORITHM = "SHA-256";
function isFileInfo(value) {
  return Boolean(value && typeof value === "object" && "mtime" in value && "size" in value);
}
async function calcEntity(entity, { algorithm = DEFAULT_ALGORITHM }) {
  // a short circuit for zero length entities
  if (entity.length === 0) {
    return `0-47DEQpj8HBSa+/TImW+5JCeuQeR`;
  }
  if (typeof entity === "string") {
    entity = encoder.encode(entity);
  }
  const hash = base64Encode(await crypto.subtle.digest(algorithm, entity)).substring(0, 27);
  return `${entity.length.toString(16)}-${hash}`;
}
async function calcFileInfo(fileInfo, { algorithm = DEFAULT_ALGORITHM }) {
  if (fileInfo.mtime) {
    const hash = base64Encode(await crypto.subtle.digest(algorithm, encoder.encode(fileInfo.mtime.toJSON()))).substring(0, 27);
    return `${fileInfo.size.toString(16)}-${hash}`;
  }
}
export async function eTag(entity, options = {}) {
  const weak = options.weak ?? isFileInfo(entity);
  const tag = await (isFileInfo(entity) ? calcFileInfo(entity, options) : calcEntity(entity, options));
  return tag ? weak ? `W/"${tag}"` : `"${tag}"` : undefined;
}
const STAR_REGEXP = /^\s*\*\s*$/;
const COMMA_REGEXP = /\s*,\s*/;
/** A helper function that takes the value from the `If-Match` header and a
 * calculated etag for the target. By using strong comparison, return `true` if
 * the values match, otherwise `false`.
 *
 * See MDN's [`If-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match)
 * article for more information on how to use this function.
 *
 * @example Usage
 * ```ts ignore
 * import {
 *   eTag,
 *   ifMatch,
 * } from "@std/http/etag";
 * import { assert } from "@std/assert";
 *
 * const body = "hello deno!";
 *
 * Deno.serve(async (req) => {
 *   const ifMatchValue = req.headers.get("if-match");
 *   const etag = await eTag(body);
 *   assert(etag);
 *   if (!ifMatchValue || ifMatch(ifMatchValue, etag)) {
 *     return new Response(body, { status: 200, headers: { etag } });
 *   } else {
 *     return new Response(null, { status: 412, statusText: "Precondition Failed"});
 *   }
 * });
 * ```
 *
 * @param value the If-Match header value.
 * @param etag the ETag to check against.
 * @returns whether or not the parameters match.
 */ export function ifMatch(value, etag) {
  // Weak tags cannot be matched and return false.
  if (!value || !etag || etag.startsWith("W/")) {
    return false;
  }
  if (STAR_REGEXP.test(value)) {
    return true;
  }
  const tags = value.split(COMMA_REGEXP);
  return tags.includes(etag);
}
/** A helper function that takes the value from the `If-None-Match` header and
 * a calculated etag for the target entity and returns `false` if the etag for
 * the entity matches the supplied value, otherwise `true`.
 *
 * See MDN's [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)
 * article for more information on how to use this function.
 *
 * @example Usage
 * ```ts ignore
 * import {
 *   eTag,
 *   ifNoneMatch,
 * } from "@std/http/etag";
 * import { assert } from "@std/assert";
 *
 * const body = "hello deno!";
 *
 * Deno.serve(async (req) => {
 *   const ifNoneMatchValue = req.headers.get("if-none-match");
 *   const etag = await eTag(body);
 *   assert(etag);
 *   if (!ifNoneMatch(ifNoneMatchValue, etag)) {
 *     return new Response(null, { status: 304, headers: { etag } });
 *   } else {
 *     return new Response(body, { status: 200, headers: { etag } });
 *   }
 * });
 * ```
 *
 * @param value the If-None-Match header value.
 * @param etag the ETag to check against.
 * @returns whether or not the parameters do not match.
 */ export function ifNoneMatch(value, etag) {
  if (!value || !etag) {
    return true;
  }
  if (STAR_REGEXP.test(value)) {
    return false;
  }
  etag = etag.startsWith("W/") ? etag.slice(2) : etag;
  const tags = value.split(COMMA_REGEXP).map((tag)=>tag.startsWith("W/") ? tag.slice(2) : tag);
  return !tags.includes(etag);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0BzdGQvaHR0cC8xLjAuMjAvZXRhZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIGFuZCBtYXRjaGluZyBFVGFncywgaW5jbHVkaW5nXG4gKiB7QGxpbmtjb2RlIGVUYWd9IHRvIGNhbGN1bGF0ZSBhbiBldGFnIGZvciBhIGdpdmVuIGVudGl0eSxcbiAqIHtAbGlua2NvZGUgaWZNYXRjaH0gZm9yIHZhbGlkYXRpbmcgaWYgYW4gRVRhZyBtYXRjaGVzIGFnYWluc3QgYSBgSWYtTWF0Y2hgXG4gKiBoZWFkZXIgYW5kIHtAbGlua2NvZGUgaWZOb25lTWF0Y2h9IGZvciB2YWxpZGF0aW5nIGFuIEV0YWcgYWdhaW5zdCBhblxuICogYElmLU5vbmUtTWF0Y2hgIGhlYWRlci5cbiAqXG4gKiBTZWUgZnVydGhlciBpbmZvcm1hdGlvbiBvbiB0aGUgYEVUYWdgIGhlYWRlciBvblxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FVGFnIHwgTUROfS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0IHsgZW5jb2RlQmFzZTY0IGFzIGJhc2U2NEVuY29kZSB9IGZyb20gXCJqc3I6QHN0ZC9lbmNvZGluZ0BeMS4wLjEwL2Jhc2U2NFwiO1xuXG4vKipcbiAqIEp1c3QgdGhlIHBhcnQgb2Yge0BsaW5rY29kZSBEZW5vLkZpbGVJbmZvfSB0aGF0IGlzIHJlcXVpcmVkIHRvIGNhbGN1bGF0ZSBhbiBgRVRhZ2AsXG4gKiBzbyBwYXJ0aWFsIG9yIHVzZXIgZ2VuZXJhdGVkIGZpbGUgaW5mb3JtYXRpb24gY2FuIGJlIHBhc3NlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlSW5mbyB7XG4gIC8qKiBUaGUgbGFzdCBtb2RpZmljYXRpb24gdGltZSBvZiB0aGUgZmlsZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYG10aW1lYFxuICAgKiBmaWVsZCBmcm9tIGBzdGF0YCBvbiBMaW51eC9NYWMgT1MgYW5kIGBmdExhc3RXcml0ZVRpbWVgIG9uIFdpbmRvd3MuIFRoaXNcbiAgICogbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy4gKi9cbiAgbXRpbWU6IERhdGUgfCBudWxsO1xuICAvKiogVGhlIHNpemUgb2YgdGhlIGZpbGUsIGluIGJ5dGVzLiAqL1xuICBzaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuY29uc3QgREVGQVVMVF9BTEdPUklUSE06IEFsZ29yaXRobUlkZW50aWZpZXIgPSBcIlNIQS0yNTZcIjtcblxuLyoqIE9wdGlvbnMgZm9yIHtAbGlua2NvZGUgZVRhZ30uICovXG5leHBvcnQgaW50ZXJmYWNlIEVUYWdPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgZGlnZXN0IGFsZ29yaXRobSB0byB1c2UgdG8gY2FsY3VsYXRlIHRoZSBldGFnLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7XCJTSEEtMjU2XCJ9XG4gICAqL1xuICBhbGdvcml0aG0/OiBBbGdvcml0aG1JZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjYWxjdWxhdGluZyB0aGUgYEVUYWdgLCBlaXRoZXIgZm9yY2luZ1xuICAgKiBhIHRhZyB0byBiZSBsYWJlbGxlZCB3ZWFrIG9yIG5vdC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYHRydWVgIHdoZW4gdGhlIGVudGl0eSBpcyBhIGBGaWxlSW5mb2AgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgd2Vhaz86IGJvb2xlYW47XG59XG5cbmZ1bmN0aW9uIGlzRmlsZUluZm8odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBGaWxlSW5mbyB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIm10aW1lXCIgaW4gdmFsdWUgJiYgXCJzaXplXCIgaW4gdmFsdWUsXG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGNFbnRpdHkoXG4gIGVudGl0eTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgeyBhbGdvcml0aG0gPSBERUZBVUxUX0FMR09SSVRITSB9OiBFVGFnT3B0aW9ucyxcbikge1xuICAvLyBhIHNob3J0IGNpcmN1aXQgZm9yIHplcm8gbGVuZ3RoIGVudGl0aWVzXG4gIGlmIChlbnRpdHkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGAwLTQ3REVRcGo4SEJTYSsvVEltVys1SkNldVFlUmA7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVudGl0eSA9IGVuY29kZXIuZW5jb2RlKGVudGl0eSk7XG4gIH1cblxuICBjb25zdCBoYXNoID0gYmFzZTY0RW5jb2RlKGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgZW50aXR5KSlcbiAgICAuc3Vic3RyaW5nKDAsIDI3KTtcblxuICByZXR1cm4gYCR7ZW50aXR5Lmxlbmd0aC50b1N0cmluZygxNil9LSR7aGFzaH1gO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxjRmlsZUluZm8oXG4gIGZpbGVJbmZvOiBGaWxlSW5mbyxcbiAgeyBhbGdvcml0aG0gPSBERUZBVUxUX0FMR09SSVRITSB9OiBFVGFnT3B0aW9ucyxcbikge1xuICBpZiAoZmlsZUluZm8ubXRpbWUpIHtcbiAgICBjb25zdCBoYXNoID0gYmFzZTY0RW5jb2RlKFxuICAgICAgYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXG4gICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUoZmlsZUluZm8ubXRpbWUudG9KU09OKCkpLFxuICAgICAgKSxcbiAgICApLnN1YnN0cmluZygwLCAyNyk7XG4gICAgcmV0dXJuIGAke2ZpbGVJbmZvLnNpemUudG9TdHJpbmcoMTYpfS0ke2hhc2h9YDtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhbiBFVGFnIGZvciBzdHJpbmcgb3IgYFVpbnQ4QXJyYXlgIGVudGl0aWVzLiBUaGlzIHJldHVybnMgYVxuICoge0BsaW5rY29kZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvRVRhZyNldGFnX3ZhbHVlIHwgc3Ryb25nIHRhZ31cbiAqIG9mIHRoZSBmb3JtIGBcIjxhc2NpaSBjaGFycz5cImAsIHdoaWNoIGd1YXJhbnRlZXMgdGhlIGJ5dGUtZm9yLWJ5dGUgZXF1YWxpdHkgb2YgdGhlIHJlc291cmNlLlxuICpcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBzZXQgdHJ1ZSB0byB0aGUgYHdlYWtgIG9wdGlvbiB0byBnZXQgYSB3ZWFrIHRhZy5cbiAqXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVUYWcgfSBmcm9tIFwiQHN0ZC9odHRwL2V0YWdcIjtcbiAqIGltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IGJvZHkgPSBcImhlbGxvIGRlbm8hXCI7XG4gKlxuICogY29uc3QgZXRhZyA9IGF3YWl0IGVUYWcoYm9keSk7XG4gKiBhc3NlcnQoZXRhZyk7XG4gKlxuICogY29uc3QgcmVzID0gbmV3IFJlc3BvbnNlKGJvZHksIHsgaGVhZGVyczogeyBldGFnIH0gfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW50aXR5IFRoZSBlbnRpdHkgdG8gZ2V0IHRoZSBFVGFnIGZvci5cbiAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgYWRkaXRpb25hbCBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIGNhbGN1bGF0ZWQgRVRhZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVUYWcoXG4gIGVudGl0eTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgb3B0aW9ucz86IEVUYWdPcHRpb25zLFxuKTogUHJvbWlzZTxzdHJpbmc+O1xuLyoqXG4gKiBDYWxjdWxhdGUgYW4gRVRhZyBmb3IgZmlsZSBpbmZvcm1hdGlvbiBlbnRpdHkuIFRoaXMgcmV0dXJucyBhXG4gKiB7QGxpbmtjb2RlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FVGFnI3cgfCB3ZWFrIHRhZ31cbiAqIG9mIHRoZSBmb3JtIGBXXFxcIjxhc2NpaSBjaGFycz5cImAsIHdoaWNoIGd1YXJhbnRlZXMgdGhlIGVxdWl2YWxlbmNlIG9mIHRoZSByZXNvdXJjZSxcbiAqIG5vdCB0aGUgYnl0ZS1mb3ItYnl0ZSBlcXVhbGl0eS5cbiAqXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVUYWcgfSBmcm9tIFwiQHN0ZC9odHRwL2V0YWdcIjtcbiAqIGltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgRGVuby5zdGF0KFwiUkVBRE1FLm1kXCIpO1xuICpcbiAqIGNvbnN0IGV0YWcgPSBhd2FpdCBlVGFnKGZpbGVJbmZvKTtcbiAqIGFzc2VydChldGFnKTtcbiAqXG4gKiB1c2luZyBmaWxlID0gYXdhaXQgRGVuby5vcGVuKFwiUkVBRE1FLm1kXCIpO1xuICpcbiAqIGNvbnN0IHJlcyA9IG5ldyBSZXNwb25zZShmaWxlLnJlYWRhYmxlLCB7IGhlYWRlcnM6IHsgZXRhZyB9IH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGVudGl0eSBUaGUgZW50aXR5IHRvIGdldCB0aGUgRVRhZyBmb3IuXG4gKiBAcGFyYW0gb3B0aW9ucyBWYXJpb3VzIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIEVUYWcuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlVGFnKFxuICBlbnRpdHk6IEZpbGVJbmZvLFxuICBvcHRpb25zPzogRVRhZ09wdGlvbnMsXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD47XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZVRhZyhcbiAgZW50aXR5OiBzdHJpbmcgfCBVaW50OEFycmF5IHwgRmlsZUluZm8sXG4gIG9wdGlvbnM6IEVUYWdPcHRpb25zID0ge30sXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCB3ZWFrID0gb3B0aW9ucy53ZWFrID8/IGlzRmlsZUluZm8oZW50aXR5KTtcbiAgY29uc3QgdGFnID1cbiAgICBhd2FpdCAoaXNGaWxlSW5mbyhlbnRpdHkpXG4gICAgICA/IGNhbGNGaWxlSW5mbyhlbnRpdHksIG9wdGlvbnMpXG4gICAgICA6IGNhbGNFbnRpdHkoZW50aXR5LCBvcHRpb25zKSk7XG5cbiAgcmV0dXJuIHRhZyA/IHdlYWsgPyBgVy9cIiR7dGFnfVwiYCA6IGBcIiR7dGFnfVwiYCA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgU1RBUl9SRUdFWFAgPSAvXlxccypcXCpcXHMqJC87XG5jb25zdCBDT01NQV9SRUdFWFAgPSAvXFxzKixcXHMqLztcblxuLyoqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHZhbHVlIGZyb20gdGhlIGBJZi1NYXRjaGAgaGVhZGVyIGFuZCBhXG4gKiBjYWxjdWxhdGVkIGV0YWcgZm9yIHRoZSB0YXJnZXQuIEJ5IHVzaW5nIHN0cm9uZyBjb21wYXJpc29uLCByZXR1cm4gYHRydWVgIGlmXG4gKiB0aGUgdmFsdWVzIG1hdGNoLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqXG4gKiBTZWUgTUROJ3MgW2BJZi1NYXRjaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9JZi1NYXRjaClcbiAqIGFydGljbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0cyBpZ25vcmVcbiAqIGltcG9ydCB7XG4gKiAgIGVUYWcsXG4gKiAgIGlmTWF0Y2gsXG4gKiB9IGZyb20gXCJAc3RkL2h0dHAvZXRhZ1wiO1xuICogaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIkBzdGQvYXNzZXJ0XCI7XG4gKlxuICogY29uc3QgYm9keSA9IFwiaGVsbG8gZGVubyFcIjtcbiAqXG4gKiBEZW5vLnNlcnZlKGFzeW5jIChyZXEpID0+IHtcbiAqICAgY29uc3QgaWZNYXRjaFZhbHVlID0gcmVxLmhlYWRlcnMuZ2V0KFwiaWYtbWF0Y2hcIik7XG4gKiAgIGNvbnN0IGV0YWcgPSBhd2FpdCBlVGFnKGJvZHkpO1xuICogICBhc3NlcnQoZXRhZyk7XG4gKiAgIGlmICghaWZNYXRjaFZhbHVlIHx8IGlmTWF0Y2goaWZNYXRjaFZhbHVlLCBldGFnKSkge1xuICogICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXM6IDIwMCwgaGVhZGVyczogeyBldGFnIH0gfSk7XG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogNDEyLCBzdGF0dXNUZXh0OiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIn0pO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgSWYtTWF0Y2ggaGVhZGVyIHZhbHVlLlxuICogQHBhcmFtIGV0YWcgdGhlIEVUYWcgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwYXJhbWV0ZXJzIG1hdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWZNYXRjaChcbiAgdmFsdWU6IHN0cmluZyB8IG51bGwsXG4gIGV0YWc6IHN0cmluZyB8IHVuZGVmaW5lZCxcbik6IGJvb2xlYW4ge1xuICAvLyBXZWFrIHRhZ3MgY2Fubm90IGJlIG1hdGNoZWQgYW5kIHJldHVybiBmYWxzZS5cbiAgaWYgKCF2YWx1ZSB8fCAhZXRhZyB8fCBldGFnLnN0YXJ0c1dpdGgoXCJXL1wiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoU1RBUl9SRUdFWFAudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0YWdzID0gdmFsdWUuc3BsaXQoQ09NTUFfUkVHRVhQKTtcbiAgcmV0dXJuIHRhZ3MuaW5jbHVkZXMoZXRhZyk7XG59XG5cbi8qKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSB2YWx1ZSBmcm9tIHRoZSBgSWYtTm9uZS1NYXRjaGAgaGVhZGVyIGFuZFxuICogYSBjYWxjdWxhdGVkIGV0YWcgZm9yIHRoZSB0YXJnZXQgZW50aXR5IGFuZCByZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGV0YWcgZm9yXG4gKiB0aGUgZW50aXR5IG1hdGNoZXMgdGhlIHN1cHBsaWVkIHZhbHVlLCBvdGhlcndpc2UgYHRydWVgLlxuICpcbiAqIFNlZSBNRE4ncyBbYElmLU5vbmUtTWF0Y2hgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvSWYtTm9uZS1NYXRjaClcbiAqIGFydGljbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0cyBpZ25vcmVcbiAqIGltcG9ydCB7XG4gKiAgIGVUYWcsXG4gKiAgIGlmTm9uZU1hdGNoLFxuICogfSBmcm9tIFwiQHN0ZC9odHRwL2V0YWdcIjtcbiAqIGltcG9ydCB7IGFzc2VydCB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IGJvZHkgPSBcImhlbGxvIGRlbm8hXCI7XG4gKlxuICogRGVuby5zZXJ2ZShhc3luYyAocmVxKSA9PiB7XG4gKiAgIGNvbnN0IGlmTm9uZU1hdGNoVmFsdWUgPSByZXEuaGVhZGVycy5nZXQoXCJpZi1ub25lLW1hdGNoXCIpO1xuICogICBjb25zdCBldGFnID0gYXdhaXQgZVRhZyhib2R5KTtcbiAqICAgYXNzZXJ0KGV0YWcpO1xuICogICBpZiAoIWlmTm9uZU1hdGNoKGlmTm9uZU1hdGNoVmFsdWUsIGV0YWcpKSB7XG4gKiAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogMzA0LCBoZWFkZXJzOiB7IGV0YWcgfSB9KTtcbiAqICAgfSBlbHNlIHtcbiAqICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHsgc3RhdHVzOiAyMDAsIGhlYWRlcnM6IHsgZXRhZyB9IH0pO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgSWYtTm9uZS1NYXRjaCBoZWFkZXIgdmFsdWUuXG4gKiBAcGFyYW0gZXRhZyB0aGUgRVRhZyB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBhcmFtZXRlcnMgZG8gbm90IG1hdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWZOb25lTWF0Y2goXG4gIHZhbHVlOiBzdHJpbmcgfCBudWxsLFxuICBldGFnOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgaWYgKCF2YWx1ZSB8fCAhZXRhZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChTVEFSX1JFR0VYUC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBldGFnID0gZXRhZy5zdGFydHNXaXRoKFwiVy9cIikgPyBldGFnLnNsaWNlKDIpIDogZXRhZztcbiAgY29uc3QgdGFncyA9IHZhbHVlLnNwbGl0KENPTU1BX1JFR0VYUCkubWFwKCh0YWcpID0+XG4gICAgdGFnLnN0YXJ0c1dpdGgoXCJXL1wiKSA/IHRhZy5zbGljZSgyKSA6IHRhZ1xuICApO1xuICByZXR1cm4gIXRhZ3MuaW5jbHVkZXMoZXRhZyk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscURBQXFEO0FBQ3JELHFDQUFxQztBQUVyQzs7Ozs7Ozs7Ozs7Q0FXQyxHQUVELFNBQVMsZ0JBQWdCLFlBQVksUUFBUSxtQ0FBbUM7QUFlaEYsTUFBTSxVQUFVLElBQUk7QUFFcEIsTUFBTSxvQkFBeUM7QUFvQi9DLFNBQVMsV0FBVyxLQUFjO0VBQ2hDLE9BQU8sUUFDTCxTQUFTLE9BQU8sVUFBVSxZQUFZLFdBQVcsU0FBUyxVQUFVO0FBRXhFO0FBRUEsZUFBZSxXQUNiLE1BQTJCLEVBQzNCLEVBQUUsWUFBWSxpQkFBaUIsRUFBZTtFQUU5QywyQ0FBMkM7RUFDM0MsSUFBSSxPQUFPLE1BQU0sS0FBSyxHQUFHO0lBQ3ZCLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQztFQUN4QztFQUVBLElBQUksT0FBTyxXQUFXLFVBQVU7SUFDOUIsU0FBUyxRQUFRLE1BQU0sQ0FBQztFQUMxQjtFQUVBLE1BQU0sT0FBTyxhQUFhLE1BQU0sT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsU0FDN0QsU0FBUyxDQUFDLEdBQUc7RUFFaEIsT0FBTyxHQUFHLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNO0FBQ2hEO0FBRUEsZUFBZSxhQUNiLFFBQWtCLEVBQ2xCLEVBQUUsWUFBWSxpQkFBaUIsRUFBZTtFQUU5QyxJQUFJLFNBQVMsS0FBSyxFQUFFO0lBQ2xCLE1BQU0sT0FBTyxhQUNYLE1BQU0sT0FBTyxNQUFNLENBQUMsTUFBTSxDQUN4QixXQUNBLFFBQVEsTUFBTSxDQUFDLFNBQVMsS0FBSyxDQUFDLE1BQU0sTUFFdEMsU0FBUyxDQUFDLEdBQUc7SUFDZixPQUFPLEdBQUcsU0FBUyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU07RUFDaEQ7QUFDRjtBQTJEQSxPQUFPLGVBQWUsS0FDcEIsTUFBc0MsRUFDdEMsVUFBdUIsQ0FBQyxDQUFDO0VBRXpCLE1BQU0sT0FBTyxRQUFRLElBQUksSUFBSSxXQUFXO0VBQ3hDLE1BQU0sTUFDSixNQUFNLENBQUMsV0FBVyxVQUNkLGFBQWEsUUFBUSxXQUNyQixXQUFXLFFBQVEsUUFBUTtFQUVqQyxPQUFPLE1BQU0sT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUc7QUFDbEQ7QUFFQSxNQUFNLGNBQWM7QUFDcEIsTUFBTSxlQUFlO0FBRXJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUNELE9BQU8sU0FBUyxRQUNkLEtBQW9CLEVBQ3BCLElBQXdCO0VBRXhCLGdEQUFnRDtFQUNoRCxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQUMsT0FBTztJQUM1QyxPQUFPO0VBQ1Q7RUFDQSxJQUFJLFlBQVksSUFBSSxDQUFDLFFBQVE7SUFDM0IsT0FBTztFQUNUO0VBQ0EsTUFBTSxPQUFPLE1BQU0sS0FBSyxDQUFDO0VBQ3pCLE9BQU8sS0FBSyxRQUFRLENBQUM7QUFDdkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0MsR0FDRCxPQUFPLFNBQVMsWUFDZCxLQUFvQixFQUNwQixJQUF3QjtFQUV4QixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU07SUFDbkIsT0FBTztFQUNUO0VBQ0EsSUFBSSxZQUFZLElBQUksQ0FBQyxRQUFRO0lBQzNCLE9BQU87RUFDVDtFQUNBLE9BQU8sS0FBSyxVQUFVLENBQUMsUUFBUSxLQUFLLEtBQUssQ0FBQyxLQUFLO0VBQy9DLE1BQU0sT0FBTyxNQUFNLEtBQUssQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLE1BQzFDLElBQUksVUFBVSxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUMsS0FBSztFQUV4QyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUM7QUFDeEIifQ==
// denoCacheMetadata=9458887855001003585,2595408444712552513