// Copyright 2018-2025 the Deno authors. MIT license.
export const padding = "=".charCodeAt(0);
export const alphabet = {
  base64: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
  base64url: new TextEncoder().encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")
};
export const rAlphabet = {
  base64: new Uint8Array(128).fill(64),
  base64url: new Uint8Array(128).fill(64)
};
alphabet.base64.forEach((byte, i)=>rAlphabet.base64[byte] = i);
alphabet.base64url.forEach((byte, i)=>rAlphabet.base64url[byte] = i);
/**
 * Calculate the output size needed to encode a given input size for
 * {@linkcode encodeIntoBase64}.
 *
 * @param originalSize The size of the input buffer.
 * @returns The size of the output buffer.
 *
 * @example Basic Usage
 * ```ts
 * import { assertEquals } from "@std/assert";
 * import { calcSizeBase64 } from "@std/encoding/unstable-base64";
 *
 * assertEquals(calcSizeBase64(1), 4);
 * ```
 */ export function calcSizeBase64(originalSize) {
  return ((originalSize + 2) / 3 | 0) * 4;
}
export function encode(buffer, i, o, alphabet, padding) {
  i += 2;
  for(; i < buffer.length; i += 3){
    const x = buffer[i - 2] << 16 | buffer[i - 1] << 8 | buffer[i];
    buffer[o++] = alphabet[x >> 18];
    buffer[o++] = alphabet[x >> 12 & 0x3F];
    buffer[o++] = alphabet[x >> 6 & 0x3F];
    buffer[o++] = alphabet[x & 0x3F];
  }
  switch(i){
    case buffer.length + 1:
      {
        const x = buffer[i - 2] << 16;
        buffer[o++] = alphabet[x >> 18];
        buffer[o++] = alphabet[x >> 12 & 0x3F];
        buffer[o++] = padding;
        buffer[o++] = padding;
        break;
      }
    case buffer.length:
      {
        const x = buffer[i - 2] << 16 | buffer[i - 1] << 8;
        buffer[o++] = alphabet[x >> 18];
        buffer[o++] = alphabet[x >> 12 & 0x3F];
        buffer[o++] = alphabet[x >> 6 & 0x3F];
        buffer[o++] = padding;
        break;
      }
  }
  return o;
}
export function decode(buffer, i, o, alphabet, padding) {
  for(let x = buffer.length - 2; x < buffer.length; ++x){
    if (buffer[x] === padding) {
      for(let y = x + 1; y < buffer.length; ++y){
        if (buffer[y] !== padding) {
          throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(buffer[y])})`);
        }
      }
      buffer = buffer.subarray(0, x);
      break;
    }
  }
  if ((buffer.length - o) % 4 === 1) {
    throw new RangeError(`Cannot decode input as base64: Length (${buffer.length - o}), excluding padding, must not have a remainder of 1 when divided by 4`);
  }
  i += 3;
  for(; i < buffer.length; i += 4){
    const x = getByte(buffer[i - 3], alphabet) << 18 | getByte(buffer[i - 2], alphabet) << 12 | getByte(buffer[i - 1], alphabet) << 6 | getByte(buffer[i], alphabet);
    buffer[o++] = x >> 16;
    buffer[o++] = x >> 8 & 0xFF;
    buffer[o++] = x & 0xFF;
  }
  switch(i){
    case buffer.length + 1:
      {
        const x = getByte(buffer[i - 3], alphabet) << 18 | getByte(buffer[i - 2], alphabet) << 12;
        buffer[o++] = x >> 16;
        break;
      }
    case buffer.length:
      {
        const x = getByte(buffer[i - 3], alphabet) << 18 | getByte(buffer[i - 2], alphabet) << 12 | getByte(buffer[i - 1], alphabet) << 6;
        buffer[o++] = x >> 16;
        buffer[o++] = x >> 8 & 0xFF;
        break;
      }
  }
  return o;
}
function getByte(char, alphabet) {
  const byte = alphabet[char] ?? 64;
  if (byte === 64) {
    throw new TypeError(`Cannot decode input as base64: Invalid character (${String.fromCharCode(char)})`);
  }
  return byte;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0BzdGQvZW5jb2RpbmcvMS4wLjEwL19jb21tb242NC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuXG5pbXBvcnQgdHlwZSB7IFVpbnQ4QXJyYXlfIH0gZnJvbSBcIi4vX3R5cGVzLnRzXCI7XG5leHBvcnQgdHlwZSB7IFVpbnQ4QXJyYXlfIH07XG5cbmV4cG9ydCBjb25zdCBwYWRkaW5nID0gXCI9XCIuY2hhckNvZGVBdCgwKTtcbmV4cG9ydCBjb25zdCBhbHBoYWJldDogUmVjb3JkPEJhc2U2NEFscGhhYmV0LCBVaW50OEFycmF5PiA9IHtcbiAgYmFzZTY0OiBuZXcgVGV4dEVuY29kZXIoKVxuICAgIC5lbmNvZGUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpLFxuICBiYXNlNjR1cmw6IG5ldyBUZXh0RW5jb2RlcigpXG4gICAgLmVuY29kZShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIiksXG59O1xuZXhwb3J0IGNvbnN0IHJBbHBoYWJldDogUmVjb3JkPEJhc2U2NEFscGhhYmV0LCBVaW50OEFycmF5PiA9IHtcbiAgYmFzZTY0OiBuZXcgVWludDhBcnJheSgxMjgpLmZpbGwoNjQpLCAvLyBhbHBoYWJldC5iYXNlNjQubGVuZ3RoXG4gIGJhc2U2NHVybDogbmV3IFVpbnQ4QXJyYXkoMTI4KS5maWxsKDY0KSxcbn07XG5hbHBoYWJldC5iYXNlNjRcbiAgLmZvckVhY2goKGJ5dGUsIGkpID0+IHJBbHBoYWJldC5iYXNlNjRbYnl0ZV0gPSBpKTtcbmFscGhhYmV0LmJhc2U2NHVybFxuICAuZm9yRWFjaCgoYnl0ZSwgaSkgPT4gckFscGhhYmV0LmJhc2U2NHVybFtieXRlXSA9IGkpO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBiYXNlNjQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXNlNjRPcHRpb25zIHtcbiAgLyoqIFRoZSBiYXNlNjQgYWxwaGFiZXQuIERlZmF1bHRzIHRvIFwiYmFzZTY0XCIgKi9cbiAgYWxwaGFiZXQ/OiBCYXNlNjRBbHBoYWJldDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZTY0IGFscGhhYmV0cy5cbiAqL1xuZXhwb3J0IHR5cGUgQmFzZTY0QWxwaGFiZXQgPSBcImJhc2U2NFwiIHwgXCJiYXNlNjR1cmxcIjtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaXplIG5lZWRlZCB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dCBzaXplIGZvclxuICoge0BsaW5rY29kZSBlbmNvZGVJbnRvQmFzZTY0fS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxTaXplIFRoZSBzaXplIG9mIHRoZSBpbnB1dCBidWZmZXIuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAZXhhbXBsZSBCYXNpYyBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICogaW1wb3J0IHsgY2FsY1NpemVCYXNlNjQgfSBmcm9tIFwiQHN0ZC9lbmNvZGluZy91bnN0YWJsZS1iYXNlNjRcIjtcbiAqXG4gKiBhc3NlcnRFcXVhbHMoY2FsY1NpemVCYXNlNjQoMSksIDQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjU2l6ZUJhc2U2NChvcmlnaW5hbFNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoKG9yaWdpbmFsU2l6ZSArIDIpIC8gMyB8IDApICogNDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShcbiAgYnVmZmVyOiBVaW50OEFycmF5XyxcbiAgaTogbnVtYmVyLFxuICBvOiBudW1iZXIsXG4gIGFscGhhYmV0OiBVaW50OEFycmF5LFxuICBwYWRkaW5nOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICBpICs9IDI7XG4gIGZvciAoOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY29uc3QgeCA9IChidWZmZXJbaSAtIDJdISA8PCAxNikgfCAoYnVmZmVyW2kgLSAxXSEgPDwgOCkgfCBidWZmZXJbaV0hO1xuICAgIGJ1ZmZlcltvKytdID0gYWxwaGFiZXRbeCA+PiAxOF0hO1xuICAgIGJ1ZmZlcltvKytdID0gYWxwaGFiZXRbeCA+PiAxMiAmIDB4M0ZdITtcbiAgICBidWZmZXJbbysrXSA9IGFscGhhYmV0W3ggPj4gNiAmIDB4M0ZdITtcbiAgICBidWZmZXJbbysrXSA9IGFscGhhYmV0W3ggJiAweDNGXSE7XG4gIH1cbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSBidWZmZXIubGVuZ3RoICsgMToge1xuICAgICAgY29uc3QgeCA9IGJ1ZmZlcltpIC0gMl0hIDw8IDE2O1xuICAgICAgYnVmZmVyW28rK10gPSBhbHBoYWJldFt4ID4+IDE4XSE7XG4gICAgICBidWZmZXJbbysrXSA9IGFscGhhYmV0W3ggPj4gMTIgJiAweDNGXSE7XG4gICAgICBidWZmZXJbbysrXSA9IHBhZGRpbmc7XG4gICAgICBidWZmZXJbbysrXSA9IHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBidWZmZXIubGVuZ3RoOiB7XG4gICAgICBjb25zdCB4ID0gKGJ1ZmZlcltpIC0gMl0hIDw8IDE2KSB8IChidWZmZXJbaSAtIDFdISA8PCA4KTtcbiAgICAgIGJ1ZmZlcltvKytdID0gYWxwaGFiZXRbeCA+PiAxOF0hO1xuICAgICAgYnVmZmVyW28rK10gPSBhbHBoYWJldFt4ID4+IDEyICYgMHgzRl0hO1xuICAgICAgYnVmZmVyW28rK10gPSBhbHBoYWJldFt4ID4+IDYgJiAweDNGXSE7XG4gICAgICBidWZmZXJbbysrXSA9IHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoXG4gIGJ1ZmZlcjogVWludDhBcnJheV8sXG4gIGk6IG51bWJlcixcbiAgbzogbnVtYmVyLFxuICBhbHBoYWJldDogVWludDhBcnJheSxcbiAgcGFkZGluZzogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgZm9yIChsZXQgeCA9IGJ1ZmZlci5sZW5ndGggLSAyOyB4IDwgYnVmZmVyLmxlbmd0aDsgKyt4KSB7XG4gICAgaWYgKGJ1ZmZlclt4XSA9PT0gcGFkZGluZykge1xuICAgICAgZm9yIChsZXQgeSA9IHggKyAxOyB5IDwgYnVmZmVyLmxlbmd0aDsgKyt5KSB7XG4gICAgICAgIGlmIChidWZmZXJbeV0gIT09IHBhZGRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBkZWNvZGUgaW5wdXQgYXMgYmFzZTY0OiBJbnZhbGlkIGNoYXJhY3RlciAoJHtcbiAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbeV0hKVxuICAgICAgICAgICAgfSlgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgwLCB4KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoKGJ1ZmZlci5sZW5ndGggLSBvKSAlIDQgPT09IDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBDYW5ub3QgZGVjb2RlIGlucHV0IGFzIGJhc2U2NDogTGVuZ3RoICgke1xuICAgICAgICBidWZmZXIubGVuZ3RoIC0gb1xuICAgICAgfSksIGV4Y2x1ZGluZyBwYWRkaW5nLCBtdXN0IG5vdCBoYXZlIGEgcmVtYWluZGVyIG9mIDEgd2hlbiBkaXZpZGVkIGJ5IDRgLFxuICAgICk7XG4gIH1cblxuICBpICs9IDM7XG4gIGZvciAoOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgeCA9IChnZXRCeXRlKGJ1ZmZlcltpIC0gM10hLCBhbHBoYWJldCkgPDwgMTgpIHxcbiAgICAgIChnZXRCeXRlKGJ1ZmZlcltpIC0gMl0hLCBhbHBoYWJldCkgPDwgMTIpIHxcbiAgICAgIChnZXRCeXRlKGJ1ZmZlcltpIC0gMV0hLCBhbHBoYWJldCkgPDwgNikgfFxuICAgICAgZ2V0Qnl0ZShidWZmZXJbaV0hLCBhbHBoYWJldCk7XG4gICAgYnVmZmVyW28rK10gPSB4ID4+IDE2O1xuICAgIGJ1ZmZlcltvKytdID0geCA+PiA4ICYgMHhGRjtcbiAgICBidWZmZXJbbysrXSA9IHggJiAweEZGO1xuICB9XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgYnVmZmVyLmxlbmd0aCArIDE6IHtcbiAgICAgIGNvbnN0IHggPSAoZ2V0Qnl0ZShidWZmZXJbaSAtIDNdISwgYWxwaGFiZXQpIDw8IDE4KSB8XG4gICAgICAgIChnZXRCeXRlKGJ1ZmZlcltpIC0gMl0hLCBhbHBoYWJldCkgPDwgMTIpO1xuICAgICAgYnVmZmVyW28rK10gPSB4ID4+IDE2O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgYnVmZmVyLmxlbmd0aDoge1xuICAgICAgY29uc3QgeCA9IChnZXRCeXRlKGJ1ZmZlcltpIC0gM10hLCBhbHBoYWJldCkgPDwgMTgpIHxcbiAgICAgICAgKGdldEJ5dGUoYnVmZmVyW2kgLSAyXSEsIGFscGhhYmV0KSA8PCAxMikgfFxuICAgICAgICAoZ2V0Qnl0ZShidWZmZXJbaSAtIDFdISwgYWxwaGFiZXQpIDw8IDYpO1xuICAgICAgYnVmZmVyW28rK10gPSB4ID4+IDE2O1xuICAgICAgYnVmZmVyW28rK10gPSB4ID4+IDggJiAweEZGO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBnZXRCeXRlKGNoYXI6IG51bWJlciwgYWxwaGFiZXQ6IFVpbnQ4QXJyYXkpOiBudW1iZXIge1xuICBjb25zdCBieXRlID0gYWxwaGFiZXRbY2hhcl0gPz8gNjQ7XG4gIGlmIChieXRlID09PSA2NCkgeyAvLyBhbHBoYWJldC5CYXNlNjQubGVuZ3RoXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBDYW5ub3QgZGVjb2RlIGlucHV0IGFzIGJhc2U2NDogSW52YWxpZCBjaGFyYWN0ZXIgKCR7XG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcilcbiAgICAgIH0pYCxcbiAgICApO1xuICB9XG4gIHJldHVybiBieXRlO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRDtBQUtyRCxPQUFPLE1BQU0sVUFBVSxJQUFJLFVBQVUsQ0FBQyxHQUFHO0FBQ3pDLE9BQU8sTUFBTSxXQUErQztFQUMxRCxRQUFRLElBQUksY0FDVCxNQUFNLENBQUM7RUFDVixXQUFXLElBQUksY0FDWixNQUFNLENBQUM7QUFDWixFQUFFO0FBQ0YsT0FBTyxNQUFNLFlBQWdEO0VBQzNELFFBQVEsSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDO0VBQ2pDLFdBQVcsSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDO0FBQ3RDLEVBQUU7QUFDRixTQUFTLE1BQU0sQ0FDWixPQUFPLENBQUMsQ0FBQyxNQUFNLElBQU0sVUFBVSxNQUFNLENBQUMsS0FBSyxHQUFHO0FBQ2pELFNBQVMsU0FBUyxDQUNmLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBTSxVQUFVLFNBQVMsQ0FBQyxLQUFLLEdBQUc7QUFlcEQ7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxPQUFPLFNBQVMsZUFBZSxZQUFvQjtFQUNqRCxPQUFPLENBQUMsQ0FBQyxlQUFlLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSTtBQUN4QztBQUVBLE9BQU8sU0FBUyxPQUNkLE1BQW1CLEVBQ25CLENBQVMsRUFDVCxDQUFTLEVBQ1QsUUFBb0IsRUFDcEIsT0FBZTtFQUVmLEtBQUs7RUFDTCxNQUFPLElBQUksT0FBTyxNQUFNLEVBQUUsS0FBSyxFQUFHO0lBQ2hDLE1BQU0sSUFBSSxBQUFDLE1BQU0sQ0FBQyxJQUFJLEVB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
// denoCacheMetadata=2258492068706513610,1466433802892397360